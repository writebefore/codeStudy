# DOM 树

字节数据 ==> 字符串 ==> 标记(Token)
标记完成之后, 这些标记会紧接着转换为 Node, 不同的 Node 会根据之前的联系构建一棵 DOM 树

# CSSOM 树

过程类似于 DOM 树的产生, 但是更加消耗性能, 因为样式可以是自行设定的, 也可能是继承获得的。这个过程浏览器得递归 CSSOM 树, 才能确定具体的元素到底是什么样式

# 渲染树

DOM 树 + CSSOM 树 = render 树
渲染树只会包括 需要显示的节点 和这些节点的样式信息, 比如 display:none, 的节点就不在渲染树中显示

## 回流(reflow)

当浏览器生成渲染树之后, 就会根据渲染树来进行布局 (回流), 然后 GPU 绘制

计算渲染树中每一个节点在设备视口的确切位置和大小, 这个计算的阶段就叫回流

## 重绘(repaint)

拿到渲染树中节点的几何信息后, 将节点转换为屏幕上的实际像素, 这个阶段叫重绘节点

# 为什么操作 DOM 慢

因为 DOM 树归渲染引擎操作, JS 归 JS 引擎操作, 当使用 js 直接操作 dom 时, 涉及到两个线程之间的通信, 势必带来性能损耗

# 什么情况阻塞渲染

js 的执行

# 优化渲染

1. html 扁平化
2. 优化 css 选择器

# 何时发生回流重绘

- 发生回流:

1. 添加或删除 可见的 DOM 元素
2. 元素的位置发生变化
3. 元素的尺寸发生变化(宽高、边框大小、内外边距)
4. 内容变化 (文本变化、替换不同尺寸的图片)
5. 页面初次渲染
6. 浏览器窗口尺寸变化

```text
回流一定会重绘, 重绘不一定会回流
```

# 浏览器的优化的机制

目前大多数浏览器都会通过队列化修改批量的回流过程, 浏览器会将修改操作放到队列里, 直到一段时间后或者达到阈值, 才会一次性回流, 清空队列。

- 但是, 获取布局信息的操作, 会强制队列刷新
  offsetTop、offsetLeft、offsetWidth、offsetHeight
  scrollTop、scrollLeft、scrollWidth、scrollHeight
  clientTop、clientLeft、clientWidth、clientHeight
  getComputedStyle
  getBoundingClientRect

# 减少回流重绘

- 修改单一 DOM:
  1. cssText
  2. 使用类名定义一系列修改，直接修改

- 批量修改DOM:
  1. 使元素脱离文档流后进行操作, 然后将元素带回文档流中

```text
脱离文档流的方式: 1. 隐藏元素display:none 2. 使用文档片段构建子树 3. 将原始元素拷贝到脱离文档的节点中, 修改后再替换原始元素
```
